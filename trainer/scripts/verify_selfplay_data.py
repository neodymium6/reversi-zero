#!/usr/bin/env python3
"""Verify selfplay data generated by Rust agent.

This script loads and verifies the NPY files generated by the Rust selfplay
system to ensure they are compatible with PyTorch training.

Usage:
    uv run python scripts/verify_selfplay_data.py <path_to_selfplay_data>

Example:
    uv run python scripts/verify_selfplay_data.py ../agent/test_selfplay
"""

import sys
from pathlib import Path

import numpy as np
import torch


def verify_selfplay_data(base_path: str) -> None:
    """Load and verify selfplay data files."""
    print(f"Loading selfplay data from: {base_path}")
    print("=" * 60)

    # Load NPY files
    states_path = f"{base_path}_states.npy"
    policies_path = f"{base_path}_policies.npy"
    values_path = f"{base_path}_values.npy"

    print("\nLoading files...")
    states = np.load(states_path)
    policies = np.load(policies_path)
    values = np.load(values_path)
    print("✓ Successfully loaded all NPY files!")

    # Print shapes and dtypes
    print("\n" + "=" * 60)
    print("Data shapes and types:")
    print("-" * 60)
    print(f"States:   shape={states.shape}, dtype={states.dtype}")
    print(f"Policies: shape={policies.shape}, dtype={policies.dtype}")
    print(f"Values:   shape={values.shape}, dtype={values.dtype}")

    # Verify shapes
    print("\n" + "=" * 60)
    print("Shape verification:")
    print("-" * 60)
    n_examples = states.shape[0]
    if states.shape != (n_examples, 3, 8, 8):  # noqa: S101
        raise ValueError(f"Expected states shape (N, 3, 8, 8), got {states.shape}")
    if policies.shape != (n_examples, 64):  # noqa: S101
        raise ValueError(f"Expected policies shape (N, 64), got {policies.shape}")
    if values.shape != (n_examples,):  # noqa: S101
        raise ValueError(f"Expected values shape (N,), got {values.shape}")
    print(f"✓ All shapes are correct for {n_examples} examples")

    # Verify data ranges
    print("\n" + "=" * 60)
    print("Data statistics:")
    print("-" * 60)
    print(f"States range:    [{states.min():.3f}, {states.max():.3f}]")
    print(f"Policies range:  [{policies.min():.6f}, {policies.max():.6f}]")
    print(f"Values range:    [{values.min():.1f}, {values.max():.1f}]")

    # Verify policies sum to 1 (approximately)
    policy_sums = policies.sum(axis=1)
    print(
        f"\nPolicy sums: mean={policy_sums.mean():.4f}, " f"std={policy_sums.std():.6f}"
    )
    if not np.allclose(policy_sums, 1.0, atol=1e-5):
        raise ValueError("Policies should sum to 1")
    print("✓ All policies sum to 1.0")

    # Verify values are in {-1, 0, 1}
    unique_values = np.unique(values)
    print(f"\nUnique values: {unique_values}")
    if not all(v in [-1.0, 0.0, 1.0] for v in unique_values):
        raise ValueError("Values should be -1, 0, or 1")
    print("✓ All values are in {-1, 0, 1}")

    # Value distribution
    value_counts = {v: np.sum(values == v) for v in unique_values}
    print("\nValue distribution:")
    for v, count in sorted(value_counts.items()):
        print(f"  {v:+.0f}: {count:4d} ({count/n_examples*100:5.1f}%)")

    # Convert to PyTorch tensors
    print("\n" + "=" * 60)
    print("PyTorch conversion:")
    print("-" * 60)
    states_tensor = torch.from_numpy(states)
    policies_tensor = torch.from_numpy(policies)
    values_tensor = torch.from_numpy(values)

    print(f"States tensor:   {states_tensor.shape}, dtype={states_tensor.dtype}")
    print(f"Policies tensor: {policies_tensor.shape}, dtype={policies_tensor.dtype}")
    print(f"Values tensor:   {values_tensor.shape}, dtype={values_tensor.dtype}")
    print("✓ Successfully converted to PyTorch tensors")

    # Show sample data
    print("\n" + "=" * 60)
    print("Sample data (first example):")
    print("-" * 60)
    print(f"State planes sum: {states[0].sum(axis=(1, 2))}")
    print("Top 5 policy moves:")
    top5_indices = np.argsort(policies[0])[-5:][::-1]
    for i, idx in enumerate(top5_indices):
        row, col = idx // 8, idx % 8
        print(f"  {i+1}. Position {idx} (row={row}, col={col}): {policies[0][idx]:.4f}")
    print(f"Value: {values[0]:+.1f}")

    print("\n" + "=" * 60)
    print("✓ All verifications passed!")
    print("=" * 60)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(__doc__)
        sys.exit(1)

    base_path = sys.argv[1]

    # Check if files exist
    for suffix in ["_states.npy", "_policies.npy", "_values.npy"]:
        if not Path(f"{base_path}{suffix}").exists():
            print(f"Error: File not found: {base_path}{suffix}")
            sys.exit(1)

    verify_selfplay_data(base_path)
